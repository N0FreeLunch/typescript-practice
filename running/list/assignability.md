## 변수의 특징
- 변수라는 것은 공간을 가지고 있다.
- `let variable = 'value'`라는 문장에서 값 `'value'`는 `variable` 변수에 대입된다.
- 변수에 값을 대입한다는 것은 변수가 가진 공간에 값을 복사해서 위치시킨다는 의미이다. `'value'`와 `variable`는 똑같이 `'value'`를 가지고 있지만 두 `'value'`는 서로 다른 존재이다.
- `==` 또는 `===`을 통해서 두 값을 비교를 할 때는 서로 동일한 존재이냐를 판별하는 것이 아니라 두 값이 똑같냐를 의미한다. 어떤 팜플렛을 받았는데 두 팜플렛은 완전히 똑같지만 서로 다른 물체이다. 미세하게 조금 다를 수 있는 것 아니냐고? 그런 건 그냥 같다고 판단하는 게 일반적이다. `==` 또는 `===`도 프로그래밍에서 이런 특징이 같으면 같은 대상이라고 판단하자라는 약속이고 컴퓨터 내부에서 서로 다른 메모리에 위치해 있다를 생각하지 않고 언어의 스펙상 똑같다고 볼 수 있다면 같다고 판단하는 것이 프로그래밍 세계에서의 일반적인 관점이다.

## 초기화
- 변수에 아무것도 넣지 않은 상태에서 변수에 문자열이든 수든 값을 넣게 되면 변수는 어떤 세팅이 된 상태가 된다. 이를 초기화되었다고 한다.
- 만약 변수에 아무런 값도 넣지 않고 변수를 사용한다면, 변수가 사용되는 시점에 `undefined`값으로 초기화가 일어난다.

## **OO을_다루는_기능**
- `'value'`라는 것은 문자열 타입이다. 문자열 타입이란 것은 문자열을 다루는 어떤 기능 안에 `'value'`라는 설정을 한 것이다.
- 변수라는 공간에 `'value'`라는 값이 복사되었다는 것은 이 변수에는 문자열을 다루는 어떤 기능이 복사되어 들어갔다는 것이고 이 기능은 'value'라는 상태를 가지고 함께 복사된 것이라고 할 수 있다.
- `let 변수 = 문자열을_다루는_기능`이라고 보면 된다. 그런데 **문자열을_다루는_기능**이 `'value'`라는 상태를 가지고 있는 것이다. 
```ts
let lastName = "King"
lastName = true
```
- codes 폴더에 `assignability.ts`라는 파일을 만들고 위의 코드를 써 보자.
- 그러면 두 번째 줄의 `lastName` 부분에 빨간 물결 밑줄이 그인다. 마우스를 가져다 놓으면 다음과 같은 에러 메시지를 볼 수 있다.
```
Type 'boolean' is not assignable to type 'string'.ts(2322)
```
- `true`는 참(true), 거짓(false)을 표기하는 불리언타입의 값이다. 불리언 타입은 `true` 또는 `false` 두 가지 값을 가지고 있다.
- `lastName`이란 변수에는 문자열 `"King"`이 들어갔는데 이것은 **문자열을_다루는_기능**이 들어간 것으로, **문자열을_다루는_기능**이 `"King"`이란 상태를 가지고 있는 것이다. 여기에다가 **불리언을_다루는_기능**을 다시 대입을 하려고 한 것이다. 이때 **불리언을_다루는_기능**은 `true`라는 상태를 가지고 있다.
- 한번 **OO을_다루는_기능**이 변수에 할당이 되어 초기화가 일어나면 초기화 된 **OO을_다루는_기능**을 다루는 기술이 아니면 다른 값으로 바꿀 수 없다. **문자열을_다루는_기능**에 불리언 값으로 상태를 바꾸겠다고 하면 **문자열을 다루는 기능**은 불리언을 다룰 수 없기 때문에 대입이 될 수 없는 것이다.
- 이런 이유는 변수에 **문자열을_다루는_기능**을 넣고 이 변수로 다양한 코드들을 짤 것이다. 그런데 이 변수를 **불리언을 다루는 기능**으로 바꾸게 되면 **문자열을_다루는_기능**에서는 사용할 수 있었던 방식이었는데 **불리언을 다루는 기능**로 바꾸고 나서는 사용할 수 없는 방식으로 바뀌게 되는 경우가 생긴다.
- 예를 들어 `lastName.length`라는 코드를 사용했다면 **문자열을_다루는_기능**에서는 문제가 없을 것이다. 하지만 **불리언을 다루는 기능**이 변수에 대입되어 바꾸게 되면 이 기능은 `.length`라는 기능을 지원하지 않기 때문에 `lastName.length`라는 코드는 타입문제가 발생하게 된다.

### 왜 다른 타입으로 재할당이 불가능한가?
- `lastName = true`는 다른 타입을 할당하는 것으로 타입스크립트에서는 불가능하지만 다른 타입의 값을 재할당할 수 있다고 가정을 해 보자.
```ts
let lastName = "King"
lastName.length
lastName = true
lastName.length
```
- 두 번째 `lastName.length`는 `lastName`이 문자열이기 때문에 **문자열을_다루는_기능** `.length`라는 기능을 사용할 수 있다.
- 하지만 네 번째 `lastName.length`는 불리언이므로 **불리언을 다루는 기능**은 `.length`라는 기능을 제공하지 않으므로 에러를 발생 시켜야 한다.
- 타입스크립트는 코드들의 사용 형태를 정해진 방식으로 쓰게 하려는 목적이 있다. 만약에 사용할 수 없는 형태의 값이 온다면 타입추론을 통해 이런 방식으로는 사용할 수 없다고 사용자에게 알려준다. 위의 코드 처럼 코드의 실행 순서가 위에서 아래로 차례대로 실행이 되는 경우에는 문자열이 들어가 있을 때와 불리언이 들어가 있을 때를 명확하게 구분을 할 수 있기 때문에 타입추론이 가능하지만, 자바스크립트의 코드는 언제 이 변수에 무슨 값이 할당되었는지 알 수 없는 코드가 상당히 많다. 이런 모든 자바스크립트 동작에 대해서 타입추론을 통해서 사용할 수 있는 코드인지 사용하지 못하는 코드인지 타입추론으로 알려 주기 위해서는 **OO을_다루는_기능**의 변경이 일어나지 않도록 하여 타입스크립트가 타입추론을 하는데 문제가 없게 해야한다.

### 타입스크립트의 목적
- 타입스크립트의 목적은 자바스크립트에 타입을 도입해서 다른 타입의 값이 들어가는 것을 막기위해 사용하는 언어이다. 따라서 타입을 제한하기 위해서 타입추론을 최대한 활용해서 다른 타입의 값이 들어가지 않도록 하는 것이 중요하다.
- 타입추론을 하기 위한 방법 중 하나로 한 번 초기화 된 변수는 다른 타입의 값으로 변경할 수 없도록 하여 어떤 타입스크립트 코드에서도 타입 추론을 할 수 있도록 하였다.

## 할당가능성(assignability)
- 특정 타입이 변수에 할당이 되면 다른 타입의 변수를 대입할 수 없고 이를 '할당가능성'이라고 부른다.
- 위에서 장황하게 설명했지만 어렵다면 한 번 초기화 된 변에 서로 다른 타입의 값을 대입할 수 없다는 것만 기억해도 충분하다. (물론 서로 다른 타입의 값을 대입할 수 있는 경우가 있긴하지만 이는 그 예외 케이스가 등장할 때 학습하기로 한다.)