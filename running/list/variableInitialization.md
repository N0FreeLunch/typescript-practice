## 변수 초기화
- 다음 두 코드의 차이점을 알아 보자.
```ts
let rocker
rocker = "Joan Jett"
```
```ts
let rocker = "Joan Jett"
```
- 첫 번째 코드는 `rocker`라는 변수를 두 번째 라인에서 변수에 값을 대입하였고, 두 번째 코드는 `rocker`를 변수를 선언하면서 값을 대입하였다.
- 타입스크립트에서 변수의 타입 결정은 변수가 선언될 때 결정이 된다. 첫 번째 코드에서 `let rocker`에는 아무 값도 할당되지 않았기 때문에 any 타입이 된다. 그에 반해 두 번째 코드에서 `let rocker = "Joan Jett"`는 변수의 선언과 동시에 문자열 값이 할당되었기 때문에 `rocker` 변수는 문자열 타입이 된다.

### any 타입의 재할당
- 첫 번째 코드의 `rocker = "Joan Jett"`을 보면 any 타입의 변수에 문자열 값을 대입하였다. 변수의 타입이 문자열이 된다.
- 하지만 이 변수의 타입은 문자열이지만, 변수의 선언과 동시에 타입이 문자열로 된 것과는 조금 다르다. 변수의 선언과 동시에 문자열 타입이 된 경우는 다른 타입으로 재할당이 불가능하지만, 변수가 any로 선언되고 나서 문자열 타입이 되었기 때문에 이 변수는 다른 타입의 값이 재할당 가능한 특징을 가지게 된다.

## 타입 에볼루션
- 변수가 any 타입으로 선언되어 있다면 다른 타입으로 변경이 되어도 타입을 재할당하는 것이 가능하다.
- 변수에 다른 타입의 값을 넣어 타입이 계속 변경되는 것을 '타입 에볼루션(evolution)'이라고 표현한다.
```ts
let rocker;
rocker = "Joan Jett";

rocker.toUpperCase();

rocker = 19.58;
rocker.toPrecision(1);

rocker.toUpperCase();
```
- `let rocker` 변수를 선언할 때 변수에 아무런 값도 할당하지 않았기 때문에 이 변수는 any 타입이 된다.
- 변수에 `Joan Jett`란 값을 대입하였기 때문에 문자열 타입이 되었다. 하지만 이 변수는 처음에 any 타입이기 때문에 문자열 타입이 되었지만, 다른 타입으로 바꿀 수 있다.
- 문자열 타입의 변수 `rocker`에 `.`을 써 주면 문자열 오브젝트로 변하게 된다. `rocker.`는 문자열 오브젝트이고 문자열 오브젝트는 문자열을 다룰 때 필요한 다양한 기능을 가지고 있다. 문자열 오브젝트의 `toUpperCase()` 메소드는 문자열의 값이 소문자라면 대문자로 바꿔주는 기능이다. 따라서 `rocker.toUpperCase()`의 결과는 `'JOAN JETT'`가 된다.
- 문자열 변수 `rocker`에 Number 타입에 해당하는 `19.58`를 할당하였다. 기본적으로 문자열 변수에 다른 타입을 할당할 수 없지만, 이 문자열은 애초에 any 타입으로 선언되어 있던 문자열이기 때문에 다른 타입으로 변경이 허가된 타입이다.
- Number 타입의 변수 `rocker`에 `.`을 써 주면 Number 오브젝트가 된다. Number 오브젝트는 수를 다루는데 필요한 다양한 기능들을 가지고 있다. Number 오브젝트의 `toPrecision()` 메소드는 수를 지수표기법으로 나타내는 기능이다. `19.58`은 거의 20에 해당하는 값이므로 `2*10^1`의 연산에 해당하는 표기법인 '2e+1'`로 나타낸다.


